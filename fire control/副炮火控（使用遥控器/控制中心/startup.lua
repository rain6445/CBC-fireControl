--[[======================================================================
    副炮中心
    v1.0.0
======================================================================
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠈⠀⠀⠈⠁⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⡔⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠁⠀⠀⠀⠀⠀⠀⠀⠀⢀⣧⠀⠀ ⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⢰⠀⠀⠀⠀⠀⠠⣶⣿⣿⡄⠀ ⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠚⠛⠛⠁⠀⠀⢷⣶⣿⣿⣇⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢹⣿⣿⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀⡠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⡆⠀⠀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠿⠟⠛⠛⠛⠉⠉⠁⠀⠀⠀⢀⣠⡾⠀⠀⠀⠀⠀⠀⠀⣠⠀⠀⢸⣿⣿⣷⠀⠀⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢀⣴⣿⡿⠁⠀⠀⠀⠀⠀⠀⣴⣿⠀⠀⢸⣿⣿⣿⡆⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⣿
⣿⣿⡿⠋⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣐⣮⣵⡿⠟⠉⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⠀⠀⢸⣿⣿⣿⣿⠀⠀⠀⠀⠑⡀⠙⢿⣿⣿⣿
⣿⡿⠀⣠⠾⠋⠀⠀⠀⢀⣠⣴⣾⣿⣿⣿⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠀⠀⠀⣿⣿⣿⣿⡀⡀⠀⠀⠀⠈⠀⠀⠙⢿⣿
⡟⠀⠀⠁⠀⠀⠀⢠⣶⣿⣿⣿⣿⣿⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⠀⠀⠀⢙⣛⡻⣿⣷⢸⡄⠀⠀⠀⠀⠀⠀⠀⠙
⠁⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣯⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠈⣿⣿⢸⣿⣷⡳⠀⠀⠀⠀⠀⠀⠀⠀
⡀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⠀⠀⠀⠀⠀⠰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠹⢋⣾⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀
⡗⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⡀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⢠⣈⡁⠀⠀⠀⠀⢙⣻⣿⣿⣿⣿⣿⡄⢧⡀⠀⠀⠀
⡇⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⡿⣿⣿⣿⣿⣿⣿⣶⣤⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⡀⠀⠀⢀⡐⣬⣿⣿⣿⣿⣿⣿⡘⣿⡄⠀⠀
⡇⢠⠀⠀⠀⠀⣄⣀⣉⣭⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣾⣿⣧⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⡘⢿⠀⠀
⣿⡌⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠃⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀
⣿⣿⣄⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠐⠀⠀⢰⠀⠀⠨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀
⣿⣿⣿⣿⣦⠀⠀⠀⠀⠈⠛⠿⣿⣿⣿⣿⣿⡿⣫⣿⣿⣿⣿⣿⣧⠀⠀⠀⡀⠀⠀⠈⠛⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀
⣿⣿⣿⣿⣿⣧⡀⠈⢶⣤⣤⣀⣀⣤⣀⣤⣶⣾⣿⣿⣿⣿⣿⣿⣿⣆⣀⡀⢀⠀⠀⢤⣄⠀⠀⢺⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇
⣿⣿⣿⣿⣿⣿⣿⣶⣤⣉⠻⠿⠿⠿⢛⣵⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠉⠆⠀⠀⢻⣿⣿⣿⣿⠏⣴⣿⣿⣿⣿⣿⣿⠁
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⢄⣠⣿⣿⣿⣿⣿⡀⠻⣿⣿⣿⣿⠿⠋⠀
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠘⣿⣿⣿⣿⣟⣿⣷⣤⣬⣉⣉⠁⠀⠀⠀
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⢹⣿⣿⣿⣿⣦⣍⣉⠉⠉⠀⢀⣀⣤⣾
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠻⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⣀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
======================================================================]]

-- 尝试打开调制解调器
peripheral.find("modem", rednet.open)

-- 全局常量
local REQUEST_PROTOCOL = "CBCcenter"  -- 用于注册请求的协议
local DATA_PROTOCOL = "CBCNumber"     -- 用于发送数字的协议
local RESET_PROTOCOL = "CBCReset"     -- 新增：用于发送重置信号的协议
-- local PASSWORD = "123456"          -- Chinese Comment: 密码已移除

-- Chinese Comment: 数据持久化
local properties, system = {}, { fileName = "center_dat", file = nil } -- 更改文件名以避免冲突

-- Chinese Comment: 重置系统属性为默认值
function system.reset() 
    return { 
        adjustStep = "0.1", -- 默认的x值，以字符串形式存储，方便UI编辑
        currentValue = 0.0  -- 初始传输值固定为0.0
    } 
end

-- Chinese Comment: 将对象写入文件进行持久化
function system.write(file, obj) 
    local f = io.open(file, "w"); 
    if f then f:write(textutils.serialise(obj)); f:close() end 
end

-- Chinese Comment: 更新持久化数据
function system.updatePersistentData() 
    system.write(system.fileName, properties) 
end

-- Chinese Comment: 初始化系统：加载或设置默认属性
function system.init() 
    local f = io.open(system.fileName, "r"); 
    if f then 
        local d = textutils.unserialise(f:read("a")); 
        f:close(); 
        properties = system.reset(); -- 首先加载默认值（包括currentValue=0.0）
        -- 仅覆盖adjustStep，currentValue始终从reset获取0.0
        if d and d.adjustStep ~= nil then properties.adjustStep = d.adjustStep end 
    else 
        properties = system.reset(); -- 如果没有文件，使用默认值
        system.updatePersistentData() -- 首次创建文件时保存默认值
    end 
    -- 确保adjustStep是字符串，方便UI编辑
    if type(properties.adjustStep) ~= "string" then
        properties.adjustStep = tostring(properties.adjustStep)
    end
end
system.init() -- 首次运行或加载时初始化属性

-- 存储所有已连接的接收器 {id = {id=id, name=name}}
local linkedReceivers = {} 
-- local registration_window_active = true -- Chinese Comment: 注册窗口标志已移除
local reset_mode_active = false -- 新增：重置模式标志

-- 红石状态跟踪
local redstone_left_active = false
local redstone_right_active = false
local redstone_front_active = false -- 新增：用于重置按钮
local last_redstone_adjust_time = os.clock()

-- Chinese Comment: 辅助函数：生成重复字符串
local function genStr(s, count)
    local result = ""
    for i = 1, count, 1 do
        result = result .. s
    end
    return result
end

-- UI界面相关工具函数和类定义
local termUtil = {
    cpX = 1,
    cpY = 1,
    fieldTb = nil,
    selectBoxTb = nil
}

local absTextField = {
    x = 1,
    y = 1,
    len = 15,
    text = "",
    textCorlor = "0",
    backgroundColor = "8"
}

function absTextField:paint()
    local str = ""
    for i = 1, self.len, 1 do
        local text = tostring(self.key[self.value])
        local tmp = string.sub(text, i, i)
        if #tmp > 0 then
            str = str .. tmp
        else
            local tmp2 = ""
            for j = 0, self.len - i, 1 do
                tmp2 = tmp2 .. " "
            end
            str = str .. tmp2
            break
        end
    end
    term.setCursorPos(self.x, self.y)
    term.blit(str, genStr(self.textCorlor, #str), genStr(self.backgroundColor, #str))
end

-- 处理文本框字符输入 (允许数字、小数点、负号)
function absTextField:inputChar(char) 
    local xPos,yPos=term.getCursorPos();xPos=xPos-self.x+1;local field=tostring(self.key[self.value]);
    if #field < self.len then
        local current_field_str = field
        local new_field_str = current_field_str

        if (char >= '0' and char <= '9') then
            new_field_str = string.sub(current_field_str,1,xPos-1)..char..string.sub(current_field_str,xPos,#current_field_str)
        elseif char == '.' then
            if not current_field_str:find('.') then -- 只允许一个小数点
                new_field_str = string.sub(current_field_str,1,xPos-1)..char..string.sub(current_field_str,xPos,#current_field_str)
            end
        elseif char == '-' then
            if xPos == 1 and not current_field_str:find('-') then -- 只允许一个前导负号
                new_field_str = char..current_field_str
            end
        end
        
        if new_field_str ~= current_field_str then -- 如果添加了有效字符
            self.key[self.value] = new_field_str -- 作为字符串存储
            termUtil.cpX=termUtil.cpX+1
        end
    end
end;

-- 处理文本框按键输入 (例如退格、左右箭头)
function absTextField:inputKey(key) 
    local xPos,yPos=term.getCursorPos();local field=tostring(self.key[self.value]);local minXp=self.x;local maxXp=minXp+#field;
    if key==259 then -- 退格键
        if xPos>minXp then
            termUtil.cpX=termUtil.cpX-1;
            if #field>0 and termUtil.cpX>=self.x then
                local index=termUtil.cpX-self.x+1; 
                field=string.sub(field,1,index-1)..string.sub(field,index+1,#field)
            end;
            self.key[self.value]=field -- 作为字符串存储
        end
    elseif key==262 then termUtil.cpX=termUtil.cpX+1 -- 右箭头
    elseif key==263 then termUtil.cpX=termUtil.cpX-1 -- 左箭头
    end;
    termUtil.cpX=termUtil.cpX>maxXp and maxXp or termUtil.cpX;
    termUtil.cpX=termUtil.cpX<minXp and minXp or termUtil.cpX
end;

-- 处理文本框点击事件 (设置光标位置)
function absTextField:click(x,y) local xPos=self.x;if x>=xPos then if x<=xPos+#tostring(self.key[self.value]) then termUtil.cpX,termUtil.cpY=x,y else termUtil.cpX,termUtil.cpY=xPos+#tostring(self.key[self.value]),y end end end;

local newTextField = function(key, value, x, y)
    return setmetatable({
        key = key,
        value = value,
        type = type(key[value]),
        x = x,
        y = y
    }, {
        __index = absTextField
    })
end

local selfId = os.getComputerID()

-- 初始化UI元素
function termUtil:init()
    self.fieldTb = {
        adjustStep = newTextField(properties, "adjustStep", 17, 2), -- 调整到第2行
        -- password = newTextField(properties, "password", 37, 1) -- 密码字段已移除
    }
    self.fieldTb.adjustStep.len = 5 
    -- self.fieldTb.password.len = 14 -- 密码字段已移除
    
    -- 默认将光标定位到第一个字段
    termUtil.cpX = self.fieldTb.adjustStep.x
    termUtil.cpY = self.fieldTb.adjustStep.y
end

-- Chinese Comment: 刷新UI显示
function termUtil:refresh()
    term.clear()
    term.setTextColor(colors.white)
    term.setBackgroundColor(colors.black)

    -- UI布局 (压缩到19行以内)
    term.setCursorPos(1, 1)
    term.write(string.format("Center ID: %d", selfId))
    -- term.setCursorPos(28, 1) -- 密码字段已移除，此行不再需要
    -- term.write("Password:") -- 密码字段已移除
    -- termUtil.fieldTb.password:paint() -- 密码字段已移除

    term.setCursorPos(1, 2)
    term.write("Adjust Step (x):") 
    termUtil.fieldTb.adjustStep:paint() 

    term.setCursorPos(1, 3)
    term.write(string.format("Current Value: %.2f", properties.currentValue)) 

    term.setCursorPos(1, 4)
    term.write(string.format("Reset Mode: %s", reset_mode_active and "ACTIVE" or "INACTIVE"))

    term.setCursorPos(1, 5)
    term.write(string.format("Connected Receivers: %d", #linkedReceivers)) -- 显示连接的接收器数量

    local y_offset = 6 -- 接收器列表的起始Y坐标
    local max_display_receivers = 10 -- 最多显示10个接收器，避免UI溢出
    local count = 0
    local sorted_ids = {}
    for id in pairs(linkedReceivers) do
        table.insert(sorted_ids, id)
    end
    table.sort(sorted_ids) 

    for _, id in ipairs(sorted_ids) do
        if count >= max_display_receivers then break end -- 限制显示数量
        local receiver = linkedReceivers[id] 
        if receiver then 
            count = count + 1
            term.setCursorPos(1, y_offset + count - 1) 
            term.write(string.format("  ID: %d", receiver.id)) -- Chinese Comment: 不再显示名称
        end
    end
    
    term.setCursorPos(termUtil.cpX, termUtil.cpY) -- 确保光标在正确位置
end

-- 监听来自接收器的注册请求 (现在是一个独立的并行任务)
local function runRegistrationListener()
    local REGISTER_RECEIVE_TIMEOUT = 0.5 -- Chinese Comment: 增加接收超时时间，提高可靠性
    while true do
        local id, msg, protocol = rednet.receive(REQUEST_PROTOCOL, REGISTER_RECEIVE_TIMEOUT)
        -- Chinese Comment: 移除 msg.name 和 msg.pw == PASSWORD 检查
        if id and protocol == REQUEST_PROTOCOL and type(msg) == "table" then -- 只需要确认是表格消息且协议正确
            if not linkedReceivers[id] then -- 只有当接收器不在列表中时才添加
                linkedReceivers[id] = {id = id} -- Chinese Comment: 只存储ID
                termUtil:refresh() -- 刷新UI
            end
        end
    end
end

-- Chinese Comment: 注册窗口UI和状态管理任务已移除，因为现在始终监听注册请求。
-- local function runRegistrationWindowUI()
--     local start_time = os.clock()
--     while os.clock() - start_time < 2 do 
--         term.setCursorPos(1, 15)
--         term.write(string.format("Registration window active... (%.1f/2.0s)", os.clock() - start_time))
--         sleep(0.1) -- 小睡眠，允许其他并行任务和UI刷新
--     end
--     registration_window_active = false 
--     term.setCursorPos(1, 15)
--     term.write("Registration window closed.               ") 
--     termUtil:refresh() -- 最终刷新UI
--     while true do sleep(60) end -- 保持此任务活跃
-- end


-- 每秒向所有连接的接收器发送当前值 (无论值是否改变)
local function sendData()
    local SEND_INTERVAL = 0.05 -- Chinese Comment: 强制每0.05秒发送一次数据
    while true do
        -- 如果处于重置模式，则不发送 DATA_PROTOCOL 数据
        if reset_mode_active then
            sleep(SEND_INTERVAL) -- 仍然保持发送间隔，但只是等待
            goto continue_send_loop
        end

        local current_adjust_step = tonumber(properties.adjustStep) or 0.0
        
        if next(linkedReceivers) ~= nil then
            local tasks = {}
            local current_receivers_ids = {}
            for id in pairs(linkedReceivers) do 
                table.insert(current_receivers_ids, id)
            end

            -- 构造要发送的数据包
            local data_to_send = {
                value = properties.currentValue,
                step = current_adjust_step
            }

            for _, id in ipairs(current_receivers_ids) do
                local receiver = linkedReceivers[id] 
                if receiver then 
                    table.insert(tasks, function()
                        rednet.send(id, data_to_send, DATA_PROTOCOL) -- 发送包含 value 和 step 的表
                    end)
                end
            end
            parallel.waitForAll(unpack(tasks)) -- 并行发送所有数据
        end
        sleep(SEND_INTERVAL) -- Chinese Comment: 每0.05秒发送一次数据
        ::continue_send_loop::
    end
end

-- 红石输入监控 (包括重置按钮)
local function runRedstoneControl()
    local REDSTONE_POLL_INTERVAL = 0.05 
    local last_front_redstone_state = redstone.getInput("front") -- 追踪前一个正面红石状态
    local last_left_redstone_state = redstone.getInput("left")
    local last_right_redstone_state = redstone.getInput("right")

    while true do
        redstone_left_active = redstone.getInput("left")
        redstone_right_active = redstone.getInput("right")
        redstone_front_active = redstone.getInput("front") -- 读取正面红石信号

        -- 检测正面红石信号的上升沿来触发重置
        if redstone_front_active and not last_front_redstone_state then
            -- 触发重置
            reset_mode_active = true
            -- 向所有连接的接收器发送重置信号
            if next(linkedReceivers) ~= nil then
                local tasks = {}
                for id in pairs(linkedReceivers) do
                    table.insert(tasks, function()
                        rednet.send(id, "RESET", RESET_PROTOCOL)
                    end)
                end
                parallel.waitForAll(unpack(tasks))
            end
            termUtil:refresh()
        end
        
        -- 如果处于重置模式，并且左右红石信号有变化，则退出重置模式
        if reset_mode_active and (redstone_left_active ~= last_left_redstone_state or redstone_right_active ~= last_right_redstone_state) then
            if redstone_left_active or redstone_right_active then -- 只要左右有任意一个红石信号活跃，就退出重置模式
                reset_mode_active = false
                termUtil:refresh()
            end
        end

        last_front_redstone_state = redstone_front_active
        last_left_redstone_state = redstone_left_active
        last_right_redstone_state = redstone_right_active
        
        sleep(REDSTONE_POLL_INTERVAL) 
    end
end

-- 值更新和循环逻辑
local function runValueUpdater()
    local MAX_VALUE = 3.14
    local MIN_VALUE = -3.14
    local ADJUST_INTERVAL = 0.05 
    local last_value_update_time = os.clock() 

    while true do
        local current_time = os.clock()
        local adjust_step_val = tonumber(properties.adjustStep) or 0.0 
        
        -- 如果处于重置模式，则不更新 currentValue
        if reset_mode_active then
            sleep(0.01)
            goto continue_updater_loop
        end

        if (current_time - last_value_update_time >= ADJUST_INTERVAL) then
            if redstone_left_active then
                properties.currentValue = properties.currentValue - adjust_step_val
            elseif redstone_right_active then
                properties.currentValue = properties.currentValue + adjust_step_val
            end
            last_value_update_time = current_time 

            if properties.currentValue > MAX_VALUE then
                properties.currentValue = MIN_VALUE 
            elseif properties.currentValue < MIN_VALUE then
                properties.currentValue = MAX_VALUE 
            end
            
            properties.currentValue = math.floor(properties.currentValue * 100 + 0.5) / 100

            system.updatePersistentData() 
            termUtil:refresh() 
        end

        ::continue_updater_loop::
        sleep(0.01) 
    end
end

-- UI交互任务
local function runTerm()
    termUtil:refresh() 
    term.setCursorBlink(true) 

    while true do
        local eventData = {os.pullEvent()}
        local event = eventData[1]

        if event == "mouse_click" or event == "key" or event == "char" then
            if event == "mouse_click" then
                local x, y = eventData[3], eventData[4]
                -- 处理 Adjust Step 输入框的点击
                if y == termUtil.fieldTb.adjustStep.y and x >= termUtil.fieldTb.adjustStep.x and x <= termUtil.fieldTb.adjustStep.x + termUtil.fieldTb.adjustStep.len then
                    termUtil.fieldTb.adjustStep:click(x, y)
                end
            elseif event == "key" then
                local key = eventData[2]
                -- 检查光标是否在 Adjust Step 输入框内
                if termUtil.cpY == termUtil.fieldTb.adjustStep.y and termUtil.cpX >= termUtil.fieldTb.adjustStep.x and termUtil.cpX <= termUtil.fieldTb.adjustStep.x + termUtil.fieldTb.adjustStep.len + 1 then
                    termUtil.fieldTb.adjustStep:inputKey(key)
                end
            elseif event == "char" then
                local char = eventData[2]
                -- 检查光标是否在 Adjust Step 输入框内
                if termUtil.cpY == termUtil.fieldTb.adjustStep.y and termUtil.cpX >= termUtil.fieldTb.adjustStep.x and termUtil.cpX <= termUtil.fieldTb.adjustStep.x + termUtil.fieldTb.adjustStep.len + 1 then
                    termUtil.fieldTb.adjustStep:inputChar(char)
                end
            end
            system.updatePersistentData() 
            termUtil:refresh() 
        end
    end
end

-- 主程序入口
local function main()
    term.clear()
    term.setCursorPos(1, 1)
    term.write("Starting Center Number Sender...")
    sleep(1) 
    
    termUtil:init() 

    -- 启动所有并行任务，包括注册监听 (现在始终活跃)
    parallel.waitForAll(runRegistrationListener, sendData, runRedstoneControl, runValueUpdater, runTerm)
end

main()
